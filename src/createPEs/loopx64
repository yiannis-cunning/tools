#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdbool.h>
#include <time.h>
#include "PEfile.h"


void passert(bool tf, char *pnt){
	if(!tf){
        //perror("(errno)");
        printf("%s\n", pnt);
	    exit(1);
	}
}

int pawrite(int fd, void *ptr, int n){
    passert(write(fd, ptr, n) == n, "Error writing bytes to file");
    return n;
}

// return next biggest number ailigned with algnmt
uint32_t align(uint32_t algnmt, uint32_t num){
    if(num % algnmt == 0){
        return num;
    }
    uint32_t t = num/algnmt;
    return num - num%algnmt + algnmt;
}


#define IMAGE_FILE_EXECUTABLE_IMAGE  0x2
#define IMAGE_FILE_DEBUG_STRIPPED 0x200
#define IMAGE_FILE_RELOCS_STRIPPED 0x1


uint8_t code[31] = {0x48, 0x83, 0xec, 0x08, 0x48, 0x31, 0xc0, 0x48, 0x81, 0xd0, 0x08, 0x00, 0x00, 0x00, 0x48, 0x81, 0xe8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x39, 0xc0, 0x74, 0xea, 0x48, 0x83, 0xc4, 0x08, 0xc3};
static uint16_t dos_header[] = {0x5a4d, 0x0090, 0x0003, 0x0000, 0x0004, 0x0000, 0xffff, 0x0000, 0x00b8, 0x0000, 0x0000, 0x0000, 0x0040, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0000, 0x1f0e, 0x0eba, 0xb400, 0xcd09, 0xb821, 0x4c01, 0x21cd, 0x6854, 0x7369, 0x7020, 0x6f72, 0x7267, 0x6d61, 0x6320, 0x6e61, 0x6f6e, 0x2074, 0x6562, 0x7220, 0x6e75, 0x6920, 0x206e, 0x4f44, 0x2053, 0x6f6d, 0x6564, 0x0d2e, 0x0a0d, 0x0024, 0x0000, 0x0000, 0x0000};
static COFF_header_t coff_header = {0};
static Shared_header_t shared_header = {0};
static PE32_plus_header_t pe_plus_header = {0};
static Section_header_t sh = {0};





int main(int argc, char *argv[]){
    passert(argc == 2, "Invalid cmd args");
    int fd = open(argv[1], O_CREAT | O_WRONLY);
    passert(fd != -1, "Cant create/open file");


    

    /*
        - Assuming 3 code sections that
            1) take up less than file_alignment of space on disk
            2) reserved less than section alignment each in memory
    */
    int file_alignment = 512;
    int section_alignment = 4096;
    int sz_headers = 128 +  sizeof(COFF_header_t) + sizeof(Shared_header_t) + sizeof(PE32_plus_header_t) + 3*sizeof(Section_header_t);


    int code_start_rva = align(section_alignment, sz_headers);
    int code_start_file = align(file_alignment, sz_headers);
    int file_size = code_start_file + file_alignment*3;       // file goes 1) header 2) sections (all aligned with file alignemt)
    
    
    int rva_size = code_start_rva + section_alignment*3;

    


    int j = 0;
    j += pawrite(fd, dos_header, 128);

    coff_header.zeros                   = 0x000;
    coff_header.signature              = 0x4550;               // PE signature
    coff_header.machine                = 0x8664;               // x014c;0x8664 -> 8684 is for x64 processors
    coff_header.section_count          = 3;
	coff_header.time_date_stamp        = 1689805076;
	coff_header.symbol_table_offset    = 0;                    // 0 means no symbol table
	coff_header.symbol_count           = 0;
	coff_header.optional_header_size   = sizeof(Shared_header_t) + sizeof(PE32_plus_header_t);
	coff_header.characteristics        = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_DEBUG_STRIPPED  | IMAGE_FILE_RELOCS_STRIPPED | 0x4;
    j += pawrite(fd, &coff_header, sizeof(COFF_header_t));


    shared_header.magic                     = 0x20b;                 // 0x20b for PE32+
    shared_header.major_linker_version      = 2;                     // 
    shared_header.minor_linker_version      = 39;                    //
    shared_header.code_size                 = 0x200;                 // Size on disk of .text section
    shared_header.initialized_data_size     = 0x400;                 // Size on disk of all (initialized) data sections
    shared_header.uninitialized_data_size   = 0;                     // ^ but un-initialized type data
    shared_header.entry_point_address       = code_start_rva;        // RVA of entry point -> RVA of .text + offset into text
    shared_header.base_of_code              = code_start_rva;        // RVA of code section
    // base_of_data ... only in PE files (non +)
    j += pawrite(fd, &shared_header, sizeof(Shared_header_t));



    pe_plus_header.image_base               = 0x00400000;           // EFI might ignore this... (where RVA starts)
    pe_plus_header.section_alignment        = section_alignment;    // Aligment of sections onece loaded into memory
    pe_plus_header.file_alignment           = file_alignment;       // Alignment of sections in file on disk
    pe_plus_header.image_size               = rva_size;             // Size of image after being loaded into memory (rounded to section alignment)
    pe_plus_header.header_size              = code_start_file;      // size of headers aligned to file alignment
    pe_plus_header.checksum                 = 0x0000;               // unknoenw
    pe_plus_header.subsystem                = 3;                    // 10 for efi, 3 for normal windows?
    pe_plus_header.major_operating_system_version = 4;
    pe_plus_header.minor_operating_system_version = 0;
    pe_plus_header.major_image_version      = 2;
    pe_plus_header.minor_image_version      = 0;
    pe_plus_header.major_subsystem_version  = 5;
    pe_plus_header.minor_subsystem_version  = 2;
    pe_plus_header.reserved1                = 0;
    pe_plus_header.dll_characteristics      = 0;
	pe_plus_header.stack_reserve_size      = 0x200000;             // MAX amount of stack size that could be allocated
	pe_plus_header.stack_commit_size       = 0x1000;               // Starting amount (1 page)
	pe_plus_header.heap_reserve_size       = 0x100000;             // MAX reservable for heap
	pe_plus_header.heap_commit_size        = 0x1000;               // starting allocated for heap
	pe_plus_header.loader_flags            = 0;                    // Reserved
	pe_plus_header.number_of_rva_and_sizes  = 16;

    uint32_t *table_ptr = &pe_plus_header.export_table_rva;
    for(int i = 0; i < pe_plus_header.number_of_rva_and_sizes; i ++){
        table_ptr[i] = 0;
    }
    j += pawrite(fd, &pe_plus_header, sizeof(PE32_plus_header_t));
    


    // Code headers
    strcpy(sh.name, ".text");
    sh.virtual_size                        = 31;                           // Size after being loaded into memory
    sh.virtual_address                     = code_start_rva;               // RVA of start of section
    sh.size_of_raw_data                    = align(file_alignment, 31);    // Size of raw code aligned to file aligment
    sh.pointer_to_raw_data                 = code_start_file;              // file pointer to start of this section
    sh.characteristics                     = 0x60500060;                   // Characteristic of section
    sh.pointer_to_relocations              = 0;
    sh.pointer_to_linenumbers              = 0;
    sh.number_of_relocations               = 0;
    sh.number_of_linenumbers               = 0;
    j += pawrite(fd, &sh, sizeof(Section_header_t));

    strcpy(sh.name, ".data");
    sh.virtual_size                        = 75;
    sh.virtual_address                     = code_start_rva + section_alignment;
    sh.size_of_raw_data                    = align(file_alignment, 75);
    sh.pointer_to_raw_data                 = code_start_file + file_alignment;
    sh.characteristics                     = 0xc0300040;
    sh.pointer_to_relocations              = 0;
    sh.pointer_to_linenumbers              = 0;
    sh.number_of_relocations               = 0;
    sh.number_of_linenumbers               = 0;
    j += pawrite(fd, &sh, sizeof(Section_header_t));

    strcpy(sh.name, ".data");
    sh.virtual_size                        = 65;
    sh.virtual_address                     = code_start_rva + section_alignment*2;
    sh.size_of_raw_data                    = align(file_alignment, 75);
    sh.pointer_to_raw_data                 = code_start_file + file_alignment*2;
    sh.characteristics                     = 0xc0300040;
    sh.pointer_to_relocations              = 0;
    sh.pointer_to_linenumbers              = 0;
    sh.number_of_relocations               = 0;
    sh.number_of_linenumbers               = 0;
    j += pawrite(fd, &sh, sizeof(Section_header_t));


    uint8_t zero = 0;
    while(j < code_start_file){
        j += pawrite(fd, &zero, 1);
    }

    j += pawrite(fd, code, 31);
    
    while(j < file_size){
        j += pawrite(fd, &zero, 1);
    }

    close(fd);

 // Want to now add a import address table...
/*
    will need a
        - import table
        - import address table
*/

}